;
; Cipher library documentation
;
; (c) Fantaisie Software
;

@Library Cipher

@Overview

  La bibliothèque Cipher propose un jeu de 
  fonctions pour le chiffrement ou 
  l'encodage des données. Par exemple la 
  signature SHA-2 est utilisée dans de nombreux domaines en 
  raison de sa résistance aux piratage.

@CommandList

@ExampleFile All Cipher.pb

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function AddCipherBuffer(#Cipher, *Entree, *Sortie, Taille)

@Description
  Ajoute de nouvelles données au 
  chiffrement démarré avec @@StartAESCipher 
  et copie les données cryptées dans le 
  tampon de sortie.

@Parameter "#Cipher"
   Le chiffrement auquel les données 
   doivent être ajoutées.

@Parameter "*Entree"
   Le tampon d'entrée.

@Parameter"*Sortie"
   Le tampon de sortie.

@Parameter "Taille"
   La taille des données à chiffrer.
   @LineBreak 
   Il s'agit de la quantité d'octets qui 
   sera lue à partir du tampon d'entrée 
   et également écrite dans le tampon de 
   sortie.
   
@NoReturnValue

@SeeAlso
  @@StartAESCipher, @@FinishCipher, 
  @@AESDecoder, @@AESEncoder
   
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = AESEncoder(*Entree, *Sortie, Taille, *Cle, Bits, *VecteurInitialisation [, Mode])

@Description
  Encode les données du tampon d'entrée 
  en utilisant l'algorithme AES dans le 
  tampon de sortie.
  
@Parameter "*Entree"
  Le tampon d'entrée avec les données en 
  clair.

@Parameter "*Sortie"
  Le tampon de sortie qui reçoit les 
  données codées. @LineBreak
  Il doit être différent du tampon 
  d'entrée.

@Parameter "Taille"
  Le nombre d'octets à encoder.@LineBreak 
  Au moins 16 octets sinon des données de 
  rembourrage doivent être ajoutées dans 
  le tampon d'entrée avant le codage, 
  afin d'obtenir ces 16 octets minimum.

@Parameter "*Cle"
  Un tampon contenant la clé de codage.@LineBreak
  @@DeriveCipherKey peut être utilisée pour créer cette clé à partir d'un mot de passe.
@FixedFont  
  Sa taille dépend du paramètre 'Bits': 
    l6 octets pour le cryptage 128 bits 
    24 octets pour le cryptage 192 bits
    32 octets pour le cryptage 256 bits
@EndFixedFont 

@Parameter "Bits"
  La taille de la clé utilisée par le 
  chiffrement. @LineBreak 
  Les valeurs valides sont 128, 192 et 256.

@Parameter "*VecteurInitialisation"
  Est un bloc tampon de données aléatoires 
  de 16 octets, utilisé pour initialiser 
  le chiffrement afin d'empêcher toute 
  violation de décodage (uniquement 
  nécessaire si vous utilisez le  mode 
  @#PB_Cipher_CBC).

@OptionalParameter "Mode"
@FixedFont  
  @#PB_Cipher_CBC: Mode par défaut (Cipher Block Chaining). Besoin de '*VecteurInitialisation'.
                  Recommandé car plus sûr que le mode ECB.
  @#PB_Cipher_ECB: Mode Alternatif (Electronic CodeBook). Pas besoin de '*VecteurInitialisation'
                  ni de chaînage(chaque bloc est codé indépendamment). Cryptage très faible comparé à CBC
                  et ne devrait pas être utilisé pour un cryptage sérieux.
@EndFixedFont

@ReturnValue
  Renvoie une valeur non nulle si 
  l'encodage a réussie, zéro sinon.

@Remarks
  AES est un algorithme de chiffrement de 
  l'industrie qui a un bon équilibre entre 
  la vitesse et la sécurité. 
  Voici l'introduction wikipedia sur AES: 
  "En cryptographie, le Advanced 
  Encryption Standard (AES) est une norme
  de cryptage adopté par le gouvernement 
  des États-Unis. La norme comprend trois 
  chiffrements par bloc, AES-128, AES-192 
  et AES-256. Chaque chiffrement AES a une 
  taille de bloc de 128 bits, avec des 
  tailles de clés de 128, 192 et 256 bits, 
  respectivement.
  Les chiffrements AES ont été analysés de 
  façon approfondie et sont maintenant 
  utilisés dans le monde entier.
@LineBreak
@LineBreak
  PureBasic utilise une mise en œuvre 
  conforme à la RFC de l'AES. 
  Plus d'informations peuvent être 
  trouvées dans le RFC 3602 : 
  @InternetLink "http://www.ietf.org/rfc/rfc3602.txt" "http://www.ietf.org/rfc/rfc3602.txt".

@Example CBC
@Code
  ; Crypter une chaîne de caractères
  ;
  String$ = "Hello voici un test pour AES"
  
  StringMemorySize = StringByteLength(String$) + SizeOf(Character) ; Espace pour la chaîne et son caractère 'nul' de terminaison de chaîne
  *CipheredString = AllocateMemory(StringMemorySize)   
  *DecipheredString = AllocateMemory(StringMemorySize) 
  
  If AESEncoder(@String$, *CipheredString, StringByteLength(String$), ?Key, 128, ?InitializationVector)
    Debug "Codé : "+PeekS(*CipheredString) ; Attention, ça s'arrêtera sur le premier octet nul, uniquement à des fins de démonstration
    
    AESDecoder(*CipheredString, *DecipheredString, StringByteLength(String$), ?Key, 128, ?InitializationVector)
    Debug "Décodé : "+PeekS(*DecipheredString)
  EndIf

  DataSection
    Key:
      Data.b $06, $a9, $21, $40, $36, $b8, $a1, $5b, $51, $2e, $03, $d5, $34, $12, $00, $06
  
    InitializationVector:
      Data.b $3d, $af, $ba, $42, $9d, $9e, $b4, $30, $b4, $22, $da, $80, $2c, $9f, $ac, $41
  EndDataSection
  
@EndCode

@Example ECB
@Code
  String$ = "Hello voici un test pour AES"
  
  *CipheredString   = AllocateMemory(StringByteLength(String$) + SizeOf(Character)) ; Espace pour la chaîne de caractère
  *DecipheredString = AllocateMemory(StringByteLength(String$) + SizeOf(Character)) ; et le caractère nul de fin de chaîne
  
  If AESEncoder(@String$, *CipheredString, MemorySize(*CipheredString), ?Key, 128, 0, #PB_Cipher_ECB)
    Debug "Chiffré: " + PeekS(*CipheredString)
    
    AESDecoder(*CipheredString, *DecipheredString, MemorySize(*DecipheredString), ?Key, 128, 0, #PB_Cipher_ECB)
    Debug "Déchiffré: " + PeekS(*DecipheredString)
  EndIf
  
  DataSection
    Key:
    Data.a $06, $a9, $21, $40, $36, $b8, $a1, $5b, $51, $2e, $03, $d5, $34, $12, $00, $06
  EndDataSection
  
@EndCode

@SeeAlso
  @@AESDecoder, @@StartAESCipher, @@DeriveCipherKey
  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = AESDecoder(*Entrée, *Sortie, Taille, *Cle, Bits, *VecteurInitialisation [, Mode])

@Description
  Décode les données du tampon d'entrée 
  en utilisant l'algorithme AES dans le 
  tampon de sortie.
    
@Parameter "*Entree"
  Le tampon d'entrée avec les données en 
  clair.

@Parameter "*Sortie"
  Le tampon de sortie qui reçoit les 
  données codées. @LineBreak
  Il doit être différent du tampon 
  d'entrée.

@Parameter "Taille"
  Le nombre d'octets à encoder.@LineBreak 
  Au moins 16 octets sinon des données 
  de rembourrage doivent être ajoutées 
  dans le tampon d'entrée avant le codage, 
  afin d'obtenir ces 16 octets minimum.

@Parameter "*Cle"
  Un tampon contenant la clé de codage.@LineBreak
  @@DeriveCipherKey peut être utilisée pour créer cette clé à partir d'un mot de passe. 
@FixedFont  
  Sa taille dépend du paramètre 'Bits': 
    l6 octets pour le cryptage 128 bits 
    24 octets pour le cryptage 192 bits
    32 octets pour le cryptage 256 bits
@EndFixedFont 

@Parameter "Bits"
  La taille de la clé utilisée par le 
  chiffrement. @LineBreak 
  Les valeurs valides sont 128, 192 et 256.

@Parameter "*VecteurInitialisation"
  Est un bloc tampon de données aléatoires, 
  utilisé pour initialiser le chiffrement
  afin d'empêcher toute violation de 
  décodage (uniquement nécessaire si vous 
  utilisez le  mode @#PB_Cipher_CBC).
  Sa taille vaut toujours 16 octets.  
  Le contenu de ce bloc doit correspondre 
  à celui qui a été utilisé pour 
  @Link "AESEncoder" "encoder" les données.

@OptionalParameter "Mode"
@FixedFont  
  @#PB_Cipher_CBC: Mode par défaut (Cipher Block Chaining). Besoin de '*VecteurInitialisation'.
                  Recommandé car plus sûr que le mode ECB.
  @#PB_Cipher_ECB: Mode Alternatif (Electronic CodeBook). Pas besoin de '*VecteurInitialisation'
                  ni de chaînage(chaque bloc est codé indépendamment). Cryptage très faible comparé à CBC
                  et ne devrait pas être utilisé pour un cryptage sérieux.
@EndFixedFont

@ReturnValue
  Renvoie une valeur non nulle si le 
  décodage a réussi, zéro sinon. 

@Remarks
  Pour plus d'informations à propos de 
  AES et voir des exemples: @@AESEncoder.

@SeeAlso
  @@AESEncoder, @@StartAESCipher, @@DeriveCipherKey
 
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat$ = CreatePasswordHash(MotDePasse$ [, FacteurdeTravail])

@Description
  Crée un résumé de hachage d'un mot de passe pour son stockage et sa vérification ultérieure.@LineBreak 
 
@Parameter "MotDePasse$"
  Le mot de passe à hasher.
  
@OptionalParameter "FacteurdeTravail"
  Ce paramètre influence la quantité de travail que la fonction de hachage devra utiliser pour 
  créer ou vérifier un hachage de mot de passe.@LineBreak 
  Plus la valeur est élevée et plus la tentative de déchiffrement d'un mot de passe par force brute 
  sera coûteux, mais cela rendra également la création et la vérification du mot de passe plus 
  coûteuses pour l'application elle-même.
@LineBreak 
@LineBreak 
  Les valeurs autorisées sont comprises entre 4 et 31. @LineBreak 
  Augmenter ce paramètre de un double la quantité de travail effectuée par la fonction pour créer 
  ou vérifier ultérieurement un mot de passe.@LineBreak  
  La valeur par défaut est 10.

@ReturnValue  
  Renvoie le hachage du mot de passe.
  
@Remarks  
  Il n'est pas possible de récupérer le mot de passe saisi à partir de la valeur de hachage, 
  mais les mots de passe peuvent être vérifiés pour voir s'ils correspondent au hachage en utilisant 
  @@VerifyPasswordHash.
@LineBreak
@LineBreak
  Le hachage du mot de passe renvoyé inclut un composant aléatoire (une valeur de 'salage') pour garantir 
  que plusieurs hachages créés à partir du même mot de passe d'entrée ne créent pas la même valeur 
  de hachage. Il n'est donc pas possible de comparer directement le résultat de cette fonction pour 
  vérifier un mot de passe. La fonction @@VerifyPasswordHash doit être appelée pour vérifier 
  un mot de passe.
@LineBreak
@LineBreak
 Cette fonction implémente l'algorithme de hachage de mot de passe bcrypt.

@Example
@Code
  ; Créer un résumé de hachage pour un stockage sécurisé
  Hash$ = CreatePasswordHash("secret")

  ; Vérifiez les mots de passe par rapport au hachage
  Debug VerifyPasswordHash("secret", Hash$)      ; correct
  Debug VerifyPasswordHash("autresecret", Hash$) ; incorrect
@EndCode

@SeeAlso
  @@VerifyPasswordHash
 
@SupportedOS
;--------------------------------------------------------------------------------------------------------

@Function Resultat = VerifyPasswordHash(MotDePasse$, Hash$)

@Description
  Vérifie si un mot de passe correspond à la valeur de hachage créée avec @@CreatePasswordHash.

@Parameter "MotDePasse$"
  Le mot de passe à vérifier.

@Parameter "Hash$"
 Le résultat de l’appel à @@CreatePasswordHash.

@ReturnValue
  Renvoie une valeur non nulle si le mot de passe correspond à la valeur de hachage, zéro sinon 
  (pas de correspondance ou valeur de hachage non valide).
.

@Example
  Voir @@CreatePasswordHash.

@SeeAlso
  @@CreatePasswordHash
 
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat$ = DESFingerprint(MotDePasse$, Cle$)

@Description
@Deprecated
  Renvoie une version cryptée DES du mot de passe.@LineBreak
  Cette commande est obsolète car elle n'est plus suffisamment sécurisée pour les utilisations modernes.@LineBreak
  Utilisez plutôt la fonction @@CreatePasswordHash.

@SeeAlso
  @@CreatePasswordHash
  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = DeriveCipherKey(MotDePasse$, Salage$, Iterations, *Cle, CleBits, Plugin [, PluginBits])

@Description
  Crée une clé de chiffrement avec le nombre spécifié de bits à partir d'un mot de passe d'entrée pour 
  une utilisation dans d'autres fonctions de chiffrement comme le cryptage ou le déchiffrement. 
  Cette fonction implémente l'algorithme de dérivation de clé PBKDF2.

@Parameter "MotDePasse$"
  Le mot de passe pour la génération de la clé.

@Parameter "Salage$"
  Une chaîne de "salage" ("salt string") afin de rendre le résultat de la fonction unique même si le 
  même mot de passe est utilisé. Cela rend les attaques par force brute plus difficiles et empêche 
  la divulgation d'informations en cas de correspondance des mots de passe.
@LineBreak
@LineBreak
  Cette valeur ne doit pas nécessairement être secrète mais elle doit être unique si possible.
  
@Parameter "Iterations"
  Le nombre d'itérations de la boucle de génération de clé PBKDF2. 
@LineBreak
@LineBreak  
  Un nombre plus élevé augmente le temps/calculs nécessaires pour calculer la clé et rend donc 
  les attaques par force brute plus difficiles.
  
@Parameter "*Cle"
  Pointeur vers l'emplacement mémoire de la clé. @LineBreak
  La zone mémoire doit avoir une taille d'au moins KeyBits/8 octets.
  
@Parameter "CleBits"
  La taille de la clé à générer en bits.
  
@Parameter "Plugin"
  Le plugin pour la fonction d'empreinte digitale à utiliser dans le calcul des clés. 
  Il peut s'agir de l'une des valeurs suivantes :
@FixedFont
  @#PB_Cipher_MD5  : Utilise l'algorithme MD5.  @@UseMD5Fingerprint doit être appelé avant d'enregistrer ce plugin.
  @#PB_Cipher_SHA1 : Utilise l'algorithme SHA1. @@UseSHA1Fingerprint doit être appelé avant d'enregistrer ce plugin.
  @#PB_Cipher_SHA2 : Utilise l'algorithme SHA2. @@UseSHA2Fingerprint doit être appelé avant d'enregistrer ce plugin.
  @#PB_Cipher_SHA3 : Utilise l'algorithme SHA3. @@UseSHA3Fingerprint doit être appelé avant d'enregistrer ce plugin.
@EndFixedFont

@OptionalParameter "PluginBits"
  Le nombre de bits à utiliser pour la fonction d'empreinte digitale (fingerpriint). Il n'est pris en 
  charge que pour le plugin suivant :
@FixedFont
  @#PB_Cipher_SHA2 : Peut être 224, 256 (par défaut), 384 ou 512.
  @#PB_Cipher_SHA3 : Peut être 224, 256 (par défaut), 384 ou 512.
@EndFixedFont
  Le nombre de bits pour la fonction d'empreinte digitale est indépendant de la taille de la clé à 
  générer. Toute combinaison est autorisée.

@ReturnValue
  Renvoie une valeur non nulle si la clé a été générée. Renvoie zéro uniquement si les paramètres du 
  plugin n'étaient pas valides.

@Example
@Code
  UseSHA2Fingerprint()
  *Cle = AllocateMemory(32)

  ; Créez une clé de 256 bits à l'aide de la fonction de hachage SHA-512 et de 500 000 itérations
  DeriveCipherKey("MotdePasseSecret", "SalageNonSecret", 500000, *Cle, 256, #PB_Cipher_SHA2, 512)

  ; Montrer la clé
  ShowMemoryViewer(*Cle, 32)
@EndCode

@SeeAlso
  @@AESEncoder, @@AESDecoder, @@StartAESCipher
 
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = StartFingerprint(#Fingerprint, Plugin [, Bits [, CleHmac$ [,FormatCleHmac]]])

@Description
  Initialise le calcul d'une empreinte en plusieurs étapes. 
@LineBreak
@LineBreak   
  Contrairement à la commande @@Fingerprint, elle permet de calculer l'empreinte de grandes 
  quantités de données sans avoir à charger le tout dans un tampon de mémoire continue. 

@Parameter "#Fingerprint"
  L'identifiant de ce calcul de type 'checksum'. 
@LineBreak
@LineBreak 
  @ReferenceLink "purebasic_objects" "#PB_Any" 
  peut est utilisé pour générer automatiquement ce nombre.

@Parameter "Plugin"
  Le plugin à utiliser. Peut être l'une des valeurs suivantes:
@FixedFont
  @#PB_Cipher_CRC32: utilise l'algorithme CRC32. @@UseCRC32Fingerprint doit être appelé avant pour utiliser le plugin.
  @#PB_Cipher_MD5  : utilise l'algorithme MD5.   @@UseMD5Fingerprint doit être appelé avant pour utiliser le plugin.
  @#PB_Cipher_SHA1 : utilise l'algorithme SHA1.  @@UseSHA1Fingerprint doit être appelé avant pour utiliser le plugin.
  @#PB_Cipher_SHA2 : utilise l'algorithme SHA2.  @@UseSHA2Fingerprint doit être appelé avant pour utiliser le plugin.
  @#PB_Cipher_SHA3 : utilise l'algorithme SHA3.  @@UseSHA3Fingerprint doit être appelé avant pour utiliser le plugin.
@EndFixedFont
  Le plugin à utiliser peut être combiné avec l'indicateur @#PB_Cipher_HMAC pour calculer un HMAC (code 
  d'authentification de message basé sur le hachage) au lieu d'une empreinte digitale normale. Dans ce 
  cas, le paramètre "CleHmac$" est également nécessaire.@LineBreak 
  Voir @@StringFingerprint pour un exemple d'utilisation de l'indicateur HMAC.
     
@OptionalParameter "Bits"
  Le nombre de bits à utiliser pour l'empreinte. Supporté seulement avec les plugins suivants:
@FixedFont
  @#PB_Cipher_SHA2 : peut être 224, 256 (par defaut), 384 ou 512.
  @#PB_Cipher_SHA3 : peut être 224, 256 (par defaut), 384 or 512.
@EndFixedFont

@OptionalParameter "CleHmac$"
    La clé secrète à utiliser dans le calcul HMAC. 
@LineBreak
@LineBreak 
  Ce paramètre n'est utilisé que si le @#PB_Cipher_HMAC est ajouté au paramètre du plugin.
  
@OptionalParameter "FormatCleHmac"
  Le format de chaîne à utiliser pour la clé HMAC. Il peut s'agir de l'une des valeurs suivantes :
@FixedFont
  @#PB_Ascii  : Encoder la clé en ASCII
  @#PB_UTF8   : Encoder la clé en UTF-8 (par défaut).
  @#PB_Unicode: Encoder la clé en Unicode
@EndFixedFont

@ReturnValue  
  Renvoie la valeur #FingerPrint si @#PB_Any a été utilisé pour ce paramètre.

@Remarks
  @@AddFingerprintBuffer permet d'ajouter des blocs de données au calcul et 
  @@FinishFingerprint le terminera et renverra le résultat.
   
@Example
@Code
  UseMD5Fingerprint()

  *Buffer = AllocateMemory(200) ; Prépare un tampon de données                 
  If *Buffer
    PokeS(*Buffer, "Le renard brun rapide saute sur le chien paresseux.", -1, #PB_Ascii)
    Taille = MemoryStringLength(*Buffer, #PB_Ascii)
    
    If StartFingerprint(0, #PB_Cipher_MD5)                ; démarre le calcul
      AddFingerprintBuffer(0, *Buffer, Taille/2)          ; calcule la partie 1
      AddFingerprintBuffer(0, *Buffer+Taille/2, Taille/2) ; calcule la partie 2
      
      MD5$ = FinishFingerprint(0)                ; termine le calcul
      Debug "MD5 checksum = " + MD5$
      
      MD5$ = Fingerprint(*Buffer, Length, #PB_Cipher_MD5)       ; comparaison avec le calcul en une seule étape
      Debug "MD5 checksum = " + MD5$      
    EndIf

    FreeMemory(*Buffer)
  EndIf
@EndCode

@SeeAlso
  @@Fingerprint, @@FileFingerprint, @@StringFingerprint
 
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function FinishCipher(#Cipher)

@Description
  Met fin au flux de cryptage préalablement 
  ouvert avec @@StartAESCipher.
  
@Parameter "#Cipher"
  Le cipher à fermer.

@NoReturnValue

@Remarks
  Cette commande devrait être appelée pour 
  clore un calcul de chiffrement même si le 
  chiffre n'est plus nécessaire car elle 
  effacera toutes les données liées au 
  calcul de chiffrement.

@SeeAlso
  @@StartAESCipher, @@AddCipherBuffer
  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = IsCipher(#Cipher)

@Description
  Teste si le numéro #Cipher donné est un chiffre valide et correctement initialisé. 

@Parameter "#Cipher"
  Le cipher à utiliser.

@ReturnValue
  Renvoie une valeur non nulle si #Cipher est un chiffre valide, zéro sinon.

@Remarks
  Cette fonction a été créée pour pouvoir passer n'importe quelle valeur en 
  paramètre sans qu'il ne puisse y avoir de plantage.
@LineBreak
@LineBreak  
  C'est la fonction idéale pour vérifier qu'un chiffre est correctement initialisé.
  
@SeeAlso
  @@StartAESCipher

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function AddFingerprintBuffer(#Fingerprint, *Tampon, Taille)

@Description
  Ajoute un nouveau tampon mémoire  dans le 
  calcul d'une somme de contrôle commencé par 
  @@StartFingerprint.
@LineBreak
@LineBreak
  La somme de contrôle renvoyée à la fin du
  calcul inclura tous les tampons ajoutés comme 
  si la somme de contrôle avait été calculée avec 
  chacun d'eux dans un seul tampon mémoire 
  contigu.

@Parameter "#FingerPrint"
  L'identifiant du calcul en cours.

@Parameter "*Tampon"  
  Le tampon qui contient les nouvelles 
  données à ajouter à l'empreinte.
  
@Parameter "Taille"  
  Le nombre d'octets à ajouter à l'empreinte.

@NoReturnValue

@Remarks  
  Voir @@StartFingerprint pour un 
  exemple d'utilisation et plus d'informations.

@SeeAlso
  @@StartFingerprint, @@FinishFingerprint

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat$ = FinishFingerprint(#Fingerprint)

@Description
  Termine le calcul d'empreinte commencé avec 
  @@StartFingerprint et renvoie la 
  signature générée dans une chaîne de caractères 
  hexadécimale.

@Parameter "#FingerPrint"
  L'identifiant du calcul à terminer.

@ReturnValue
  Renvoie l'empreinte sous forme d'une chaîne 
  de caractères hexadécimale.
  
@Remarks
 Cette commande doit toujours être appelée 
 pour terminer un calcul, même si la 
 signature n'est plus nécessaire, car elle 
 libère toutes les données associées au 
 calcul.
@LineBreak
@LineBreak
  Voir @@StartFingerprint pour un 
  exemple d'utilisation et plus d'informations.

@SeeAlso
  @@StartFingerprint, @@AddFingerprintBuffer

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = IsFingerprint(#Fingerprint)

@Description
  Teste si un '#Fingerprint' est bien un calcul 
  d'empreinte valide commencé par 
  @@StartFingerprint.
  
@Parameter "#FingerPrint"  
  L'empreinte à tester.
  
@ReturnValue  
  Renvoie une valeur non nulle si l'empreinte 
  est valide, zéro sinon.
  
@Remarks  
  Cette fonction a été conçue pour pouvoir 
  passer n'importe quelle valeur en 
  paramètre sans qu'il ne puisse y avoir 
  de plantage. C'est la fonction idéale 
  pour vérifier qu'un objet est 
  correctement initialisé.  

@SeeAlso
  @@StartFingerprint
    
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat$ = FileFingerprint(Fichier$, Plugin [, Bits  [, Decalage [, Longueur [, CleHmac$ [,FormatCleHmac]]]]])

@Description
  Renvoie une empreinte d'un fichier.
  
@Parameter "Fichier$"  
  Le nom du fichier à utiliser.

@Parameter "Plugin"
  Le plugin à utiliser. Peut être l'une des valeurs suivantes:
@FixedFont
  @#PB_Cipher_CRC32: utilise l'algorithme CRC32. @@UseCRC32Fingerprint doit être appelé avant pour utiliser le plugin.
  @#PB_Cipher_MD5  : utilise l'algorithme MD5.   @@UseMD5Fingerprint doit être appelé avant pour utiliser le plugin.
  @#PB_Cipher_SHA1 : utilise l'algorithme SHA1.  @@UseSHA1Fingerprint doit être appelé avant pour utiliser le plugin.
  @#PB_Cipher_SHA2 : utilise l'algorithme SHA2.  @@UseSHA2Fingerprint doit être appelé avant pour utiliser le plugin.
  @#PB_Cipher_SHA3 : utilise l'algorithme SHA3.  @@UseSHA3Fingerprint doit être appelé avant pour utiliser le plugin.
@EndFixedFont
  Le plugin à utiliser peut être combiné avec l'indicateur @#PB_Cipher_HMAC pour calculer un HMAC (code 
  d'authentification de message basé sur le hachage) au lieu d'une empreinte digitale normale. Dans ce 
  cas, le paramètre "CleHmac$" est également nécessaire.@LineBreak 
  Voir @@StringFingerprint pour un exemple d'utilisation de l'indicateur HMAC.
  
@OptionalParameter "Bits"
  Le nombre de bits à utiliser pour l'empreinte. Supporté seulement avec les plugins suivants:
@FixedFont
  @#PB_Cipher_SHA2 : peut être 224, 256 (par defaut), 384 ou 512.
  @#PB_Cipher_SHA3 : peut être 224, 256 (par defaut), 384 or 512.
@EndFixedFont
  
@OptionalParameter "Decalage"
  Le décalage en octets (offset), à partir du début du fichier avant de lancer le calcul de la somme 
  de contrôle.

@OptionalParameter "Longueur"
  La longueur (en octets) à utiliser pour le calcul de la somme de contrôle.
 
@OptionalParameter "CleHmac$"
    La clé secrète à utiliser dans le calcul HMAC. 
@LineBreak
@LineBreak 
  Ce paramètre n'est utilisé que si le @#PB_Cipher_HMAC est ajouté au paramètre du plugin.
  
@OptionalParameter "FormatCleHmac"
  Le format de chaîne à utiliser pour la clé HMAC. Il peut s'agir de l'une des valeurs suivantes :
@FixedFont
  @#PB_Ascii  : Encoder la clé en ASCII
  @#PB_UTF8   : Encoder la clé en UTF-8 (par défaut).
  @#PB_Unicode: Encoder la clé en Unicode
@EndFixedFont
 
@ReturnValue  
  Renvoie l'empreinte si le calcul a été un succès.
@LineBreak
@LineBreak   
   Si le fichier est introuvable ou qu'une erreur s'est produite, le résultat sera une chaîne de 
   caractères vide.

@SeeAlso
  @@Fingerprint, @@StartFingerprint, @@StringFingerprint
  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat$ = Fingerprint(*Tampon, Taille, Plugin [, Bits [, CleHmac$ [,FormatCleHmac]]])

@Description
  Renvoie l'empreinte des données contenues 
  dans un tampon.

@Parameter "*Tampon"
  Le tampon contenant les données.

@Parameter "Taille"
  La taille du tampon.

@Parameter "Plugin"
  Le plugin à utiliser. Peut être l'une des valeurs suivantes:
@FixedFont
  @#PB_Cipher_CRC32: utilise l'algorithme CRC32. @@UseCRC32Fingerprint doit être appelé avant pour utiliser le plugin.
  @#PB_Cipher_MD5  : utilise l'algorithme MD5.   @@UseMD5Fingerprint doit être appelé avant pour utiliser le plugin.
  @#PB_Cipher_SHA1 : utilise l'algorithme SHA1.  @@UseSHA1Fingerprint doit être appelé avant pour utiliser le plugin.
  @#PB_Cipher_SHA2 : utilise l'algorithme SHA2.  @@UseSHA2Fingerprint doit être appelé avant pour utiliser le plugin.
  @#PB_Cipher_SHA3 : utilise l'algorithme SHA3.  @@UseSHA3Fingerprint doit être appelé avant pour utiliser le plugin.
@EndFixedFont
  Le plugin à utiliser peut être combiné avec l'indicateur @#PB_Cipher_HMAC pour calculer un HMAC (code 
  d'authentification de message basé sur le hachage) au lieu d'une empreinte digitale normale. Dans ce 
  cas, le paramètre "CleHmac$" est également nécessaire.@LineBreak 
  Voir @@StringFingerprint pour un exemple d'utilisation de l'indicateur HMAC.
  
@OptionalParameter "Bits"
  Le nombre de bits à utiliser pour l'empreinte. Supporté seulement avec les plugins suivants:
@FixedFont
  @#PB_Cipher_SHA2 : peut être 224, 256 (par defaut), 384 ou 512.
  @#PB_Cipher_SHA3 : peut être 224, 256 (par defaut), 384 or 512.
@EndFixedFont

@OptionalParameter "CleHmac$"
    La clé secrète à utiliser dans le calcul HMAC. 
@LineBreak
@LineBreak 
  Ce paramètre n'est utilisé que si le @#PB_Cipher_HMAC est ajouté au paramètre du plugin.
  
@OptionalParameter "FormatCleHmac"
  Le format de chaîne à utiliser pour la clé HMAC. Il peut s'agir de l'une des valeurs suivantes :
@FixedFont
  @#PB_Ascii  : Encoder la clé en ASCII
  @#PB_UTF8   : Encoder la clé en UTF-8 (par défaut).
  @#PB_Unicode: Encoder la clé en Unicode
@EndFixedFont

@ReturnValue
  Renvoie l'empreinte sous forme d'une chaîne de caractères hexadécimale.

@Example (Une chaîne en tant que tampon mémoire)
@Code
  UseMD5Fingerprint()
  test.s = "Ceci est un test avec une chaîne!"
  Debug Fingerprint(@test, Len(test), #PB_Cipher_MD5)
@EndCode

@Example (Avec un tampon mémoire)
@Code
  UseMD5Fingerprint()

  *Buffer = AllocateMemory(500)    
  If *Buffer
    PokeS(*Buffer, "Le renard brun rapide saute sur le chien paresseux.", -1, #PB_Ascii)
    MD5$ = Fingerprint(*Buffer, MemoryStringLength(*Buffer, #PB_Ascii), #PB_Cipher_MD5)
    Debug "MD5 Fingerprint = " + MD5$
    FreeMemory(*Buffer)  ; sera libéré aussi à la fin du programme automatiquement
  EndIf
@EndCode

@SeeAlso
  @@FileFingerprint, @@StartFingerprint, @@StringFingerprint
   
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat$ = StringFingerprint(Texte$, Plugin [, Bits [, Format [, CleHmac$ [,FormatCleHmac]]]])

@Description 
  Renvoie l'empreinte d'une chaîne de caractères.

@Parameter "Texte$"
   La chaîne de caractères.

@Parameter "Plugin"
  Le plugin à utiliser. Peut être l'une des valeurs suivantes:
@FixedFont
  @#PB_Cipher_CRC32: utilise l'algorithme CRC32. @@UseCRC32Fingerprint doit être appelé avant pour utiliser le plugin.
  @#PB_Cipher_MD5  : utilise l'algorithme MD5.   @@UseMD5Fingerprint doit être appelé avant pour utiliser le plugin.
  @#PB_Cipher_SHA1 : utilise l'algorithme SHA1.  @@UseSHA1Fingerprint doit être appelé avant pour utiliser le plugin.
  @#PB_Cipher_SHA2 : utilise l'algorithme SHA2.  @@UseSHA2Fingerprint doit être appelé avant pour utiliser le plugin.
  @#PB_Cipher_SHA3 : utilise l'algorithme SHA3.  @@UseSHA3Fingerprint doit être appelé avant pour utiliser le plugin.
@EndFixedFont
  Le plugin peut être combiné avec l'indicateur @#PB_Cipher_HMAC pour calculer un HMAC (code 
  d'authentification de message basé sur le hachage) au lieu d'une empreinte digitale normale. 
  Dans ce cas, le paramètre "CleHmac$" est également nécessaire.

@OptionalParameter "Bits"
  Le nombre de bits à utiliser pour l'empreinte. Supporté seulement avec les plugins suivants:
@FixedFont
  @#PB_Cipher_SHA2 : peut être 224, 256 (par defaut), 384 ou 512.
  @#PB_Cipher_SHA3 : peut être 224, 256 (par defaut), 384 or 512.
@EndFixedFont

@OptionalParameter "Format"
  Le format de la chaîne de caractères à utiliser avant 
  le 'hashage'.@LineBreak
  Peut être l'une des valeurs suivantes:
@FixedFont  
  @#PB_UTF8    : la chaîne sera 'hashée' au format UTF8 (par défaut).
  @#PB_Ascii   : la chaîne sera 'hashée' au format ASCII.
  @#PB_Unicode : la chaîne sera 'hashée' au format Unicode (UTF16).
@EndFixedFont

@OptionalParameter "CleHmac$"
    La clé secrète à utiliser dans le calcul HMAC. 
@LineBreak
@LineBreak 
  Ce paramètre n'est utilisé que si le @#PB_Cipher_HMAC est ajouté au paramètre du plugin.
  
@OptionalParameter "FormatCleHmac"
  Le format de chaîne à utiliser pour la clé HMAC. Il peut s'agir de l'une des valeurs suivantes :
@FixedFont
  @#PB_Ascii  : Encoder la clé en ASCII
  @#PB_UTF8   : Encoder la clé en UTF-8 (par défaut).
  @#PB_Unicode: Encoder la clé en Unicode
@EndFixedFont

@ReturnValue
  Renvoie l'empreinte sous forme d'une chaîne 
  de caractères hexadécimale.
  
@Example
@Code
  UseMD5Fingerprint()

  Debug StringFingerprint("UnMotdePasse", #PB_Cipher_MD5)
@EndCode

@Example HMAC
@Code
  UseSHA2Fingerprint()

  ; Utilise hmacSha256 avec la clé et le message en ascii.
  ; Devrait être 4643978965ffcec6e6d73b36a39ae43ceb15f7ef8131b8307862ebc560e7f988.
   Debug StringFingerprint("le message à hacher ici", #PB_Cipher_SHA2|#PB_Cipher_HMAC, 256, #PB_Ascii, "la clé secrète partagée ici", #PB_Ascii)
@EndCode

@SeeAlso
  @@FileFingerprint, @@StartFingerprint, @@Fingerprint
 
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function UseMD5Fingerprint()

@Description
  Déclare le plugin de prise d'empreinte MD5 pour une 
  utilisation future.

@NoParameters

@NoReturnValue
  
@Remarks
  Voici une explication rapide tireé de la RFC 1321 
  sur MD5:
@LineBreak  
@LineBreak
  L'algorithme prend en entrée un message de longueur 
  arbitraire et produit en sortie une "empreinte 
  digitale" 128 bits ou un "Message Digest" de l'entrée.
  On suppose qu'il est mathématiquement impossible de 
  produire deux messages ayant la même empreinte, 
  ou de produire un message ayant un message digest 
  cible pré-spécifié. L'algorithme MD5 est destiné 
  à la production de signatures numériques.'
@LineBreak  
@LineBreak
   MD5 est souvent utilisé pour le cryptage des 
   mots de passe mais il doit être évité car il 
   est a été jugé vulnérable à certaines attaques.
   Plus d'informations peuvent être trouvées dans 
   la RFC 1321:
   @InternetLink "Http://www.ietf.org/rfc/rfc1321.txt" "http://www.ietf.org/rfc/rfc1321.txt".

@Example  
@Code
  UseMD5Fingerprint()

  Debug StringFingerprint("UnMotdePasse", #PB_Cipher_MD5)
@EndCode

@SeeAlso
  @@UseSHA1Fingerprint(), @@UseSHA2Fingerprint(), 
  @@UseSHA3Fingerprint(), @@UseCRC32Fingerprint()

  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function UseSHA1Fingerprint()

@Description
  Déclare le plugin de prise d'empreinte SHA1 pour une 
  utilisation future.

@NoParameters

@NoReturnValue

@Remarks
  SHA1 peut être utilisé pour calculer une somme de 
  contrôle pour vérifier si un message n'a pas été 
  modifié. contrairement à 
  @Link "UseCRC32Fingerprint" "CRC32", il est presque 
  impossible de modifier le message d'origine et de 
  produire la même empreinte SHA1.
@LineBreak
@LineBreak
   Voici une explication rapide tiré de la RFC 3174 
   sur SHA1:
@LineBreak
@LineBreak
  'La SHA-1 est dite sécurisée car il est 
  mathématiquement impossible de trouver un message 
  digest qui correspond à un message donné, ou de 
  trouver deux messages différents qui produisent le 
  même message digest.
  Toute modification d'un message en transit donnera, 
  avec une très forte probabilité, une autre empreinte, 
  et la signature sera différente. "
@LineBreak
@LineBreak
   Plus d'informations peuvent être trouvées dans la 
   RFC 3174:
   @InternetLink "Http://www.ietf.org/rfc/rfc3174.txt" "http://www.ietf.org/rfc/rfc3174.txt".

@Example  
@Code
  UseSHA1Fingerprint()

  Debug StringFingerprint("UnMotdePasse", #PB_Cipher_SHA1)
@EndCode

@SeeAlso
  @@UseMD5Fingerprint(), @@UseSHA2Fingerprint(), 
  @@UseSHA3Fingerprint(), @@UseCRC32Fingerprint()

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function UseSHA2Fingerprint()

@Description
  Déclare le plugin de prise d'empreinte SHA2 pour une 
  utilisation future.
  
@NoParameters

@NoReturnValue

@Remarks
  Sur @InternetLink "https://fr.wikipedia.org/wiki/SHA-2" "Wikipedia": 
  SHA-2 comprend des changements importants par rapport  
  à son prédécesseur, SHA-1.
  En 2005, un algorithme a émergé qui a trouvé des 
  collisions SHA-1 avec environ 2000 fois moins d'étapes 
  que prévu.
  Bien qu'(à partir de 2015) aucun exemple de collision 
  SHA-1 n'aie encore été publié, la marge de sécurité 
  laissée par SHA-1 est plus faible que prévu, et son 
  utilisation n'est donc plus recommandée pour les 
  applications qui réclament une forte  résistance aux 
  collisions, notamment concernant les signatures 
  numériques.
  Bien que SHA-2 présente une certaine similitude avec 
  l'algorithme SHA-1, ces attaques ont pas été étendues 
  avec succès à SHA-2.

@Example  
@Code
  UseSHA2Fingerprint()

  Debug StringFingerprint("UnMotdePasse", #PB_Cipher_SHA2, 512) ; Use SHA2-512 variant
@EndCode

@SeeAlso
  @@UseMD5Fingerprint(), @@UseSHA1Fingerprint(), 
  @@UseSHA3Fingerprint(), @@UseCRC32Fingerprint()

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function UseSHA3Fingerprint()

@Description
  Déclare le plugin de prise d'empreinte SHA3 pour une 
  utilisation future. Les standards 224-bits, 256 bits,
  384 bits et 512 bits sont pris en charge.
  
@NoParameters

@NoReturnValue

@Example  
@Code
  UseSHA3Fingerprint()

  Debug StringFingerprint("UnMotdePasse", #PB_Cipher_SHA3, 512) ; Utilisation de SHA3-512
@EndCode

@SeeAlso
  @@UseMD5Fingerprint(), @@UseSHA1Fingerprint(), 
  @@UseSHA2Fingerprint(), @@UseCRC32Fingerprint()

@SupportedOS
;--------------------------------------------------------------------------------------------------------

@Function UseCRC32Fingerprint()

@Description
  Déclare le plugin de prise d'empreinte CRC32 pour une 
  utilisation future.  

@NoParameters

@NoReturnValue

@Remarks
  CRC32 est un codage 32 bits qui n'est pas 
  conçu pour le stockage de mot de passe car 
  il est facilement piratable, mais 
  utilisable pour des contrôles rapides 
  d'intégrité des données. Par exemple les 
  fichiers ZIP ont une somme de contrôle à la 
  fin du fichier pour vérifier qu'il n'est pas 
  corrompu.@LineBreak
  Le principal avantage de l'algorithme 
  CRC32 sur le hachage MD5 ou autre est 
  sa très grande vitesse.

@Example  
@Code
  UseCRC32Fingerprint()

  Debug StringFingerprint("du texte", #PB_Cipher_CRC32)
@EndCode

@SeeAlso
  @@UseMD5Fingerprint(), @@UseSHA1Fingerprint(), 
  @@UseSHA2Fingerprint(), @@UseSHA3Fingerprint()

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = Base64DecoderBuffer(*TamponSource, LongueurSource, *TamponDestination, LongueurDestination)  

@Description
  Décode un tampon codé en 
  @Link "Base64EncoderBuffer" "Base64". 

@Parameter "*TamponSource"
  Le tampon contenant les données codées.

@Parameter "LongueurSource"
  La taille de la mémoire tampon d'entrée.

@Parameter "*TamponDestination"
  Le tampon de sortie où les données 
  seront copiées.

@Parameter "LongueurDestination"
  La taille de la mémoire tampon de sortie.
@Indent
  La mémoire tampon de sortie peut être 
  jusqu'à 25% plus petite que le tampon 
  d'entrée, avec une taille minimale de 
  64 octets.@LineBreak
  Il est recommandé de faire un tampon 
  légèrement plus grand, par exemple 20%, 
  pour éviter les débordements.
@EndIndent

@ReturnValue
   Renvoie la longueur des données 
   décodées en octets.

@Example Encodage & Décodage d'une variable texte
@Code
  Exemple$ = "Voici une phrase !" 
  Decoded$ = Space(1024) 
  Encoded$ = Space(1024) 
    
  Debug Base64EncoderBuffer(@Exemple$, StringByteLength(Exemple$), @Encoded$, StringByteLength(Encoded$))
  Debug Encoded$ 
    
  Debug Base64DecoderBuffer(@Encoded$, StringByteLength(Encoded$), @Decoded$, StringByteLength(Decoded$))
  Debug Decoded$
@EndCode

@Example Encodage & Décodage d'une DataSection
@Code
  DataSection
    TestDebut:
    Data.a $00, $01, $02, $03, $04, $05, $06, $07
    Data.a $08, $09, $0A, $0B, $0C, $0D, $0E, $0F
    TestFin:
  EndDataSection
  
  Taille = (?TestFin - ?TestDebut) * 1.35
  If Taille < 64
  Taille = 64
  EndIf
  
  *EncodeBuffer = AllocateMemory(Taille)
  Taille = Base64EncoderBuffer(?TestDebut, ?TestFin - ?TestDebut, *EncodeBuffer, MemorySize(*EncodeBuffer))
  ChaineEncodee$ = PeekS(*EncodeBuffer, Taille, #PB_Ascii)
  Debug ChaineEncodee$
  
  *DecodeBuffer = AllocateMemory(Taille)
  Taille = PokeS(*EncodeBuffer, ChaineEncodee$, StringByteLength(ChaineEncodee$, #PB_Ascii), #PB_Ascii|#PB_String_NoZero)
  Taille = Base64DecoderBuffer(*EncodeBuffer, Taille, *DecodeBuffer, MemorySize(*DecodeBuffer))
  ShowMemoryViewer(*DecodeBuffer, Taille)
@EndCode

@Example Problème de décodage d'une variable texte déjà codé en Base64 par un logiciel externe
@Code
  ; Attention, il est délicat d'utiliser une variable pour décoder un texte
  ; déjà codé en Base64 par un logiciel externe (messagerie par exemple)
  
  Encoded$ = "Vm9pY2kgdW5lIHBocmFzZSAh" ;"Voici une phrase !", codée en Base64 utf8
  Decoded$ = Space(1024) 
   
  Debug Base64DecoderBuffer(@Encoded$, StringByteLength(Encoded$), @Decoded$, 1024)
  Debug Decoded$ ; ==> Affiche n'importe quoi
  
  ; Pour résoudre ce problème, suivre la procédure ci-dessous
  
  ; Différents exemples de textes déjà codés
  Encode_utf8$      = "Vm9pY2kgdW5lIHBocmFzZSBow6kgIQ0K" ;Voici une phrase hé !, codée en Base64 utf8
  Encode_iso8859_1$ = "Vm9pY2kgdW5lIHBocmFzZSBo6SAhDQo=" ;Voici une phrase hé !, codée en Base64 iso8859_1$
  Encode_ascii$     = "Vm9pY2kgdW5lIHBocmFzZSBoICENCg==" ;Voici une phrase hé !, codée en Base64 ascii 

  Procedure.s Decode64(Texte64.s, Option=#PB_UTF8)
    Protected *in, *out
    Protected Resultat.s
  
    *in = Ascii(Texte64) ; Le texte codé en Base64 est supposé être en ascii pour PureBasic
    If *in <> 0
      ; La mémoire tampon de sortie peut être jusqu'à 33% plus petite que le tampon d'entrée
      *out = AllocateMemory(MemoryStringLength(*in,#PB_Ascii) * 0.8) ; Ici nous prenons une valeur de 20%
      If *out <> 0
        Base64DecoderBuffer(*in, MemorySize(*in), *out, MemorySize(*out))  ; Décodage...
        Resultat = PeekS(*out, -1, Option) ; Le résultat est transféré dans une variable
        FreeMemory(*out)
      EndIf
      FreeMemory(*in)
    EndIf
    ProcedureReturn Resultat
  EndProcedure

  Debug Decode64(Encode_utf8$)                 ; Affiche: Voici une phrase hé !
  Debug Decode64(Encode_iso8859_1$, #PB_Ascii) ; Affiche: Voici une phrase hé ! (iso8859_1 est aussi appelée Latin-1 ou Europe occidentale et contient tous les caractères ascii)
  Debug Decode64(Encode_ascii$, #PB_Ascii)     ; Affiche: Voici une phrase h ! (problème avec lettres accentuées...)
                                               ; car le codage Base64 ascii s'arrête au caractère ascii n°127
@EndCode

@SeeAlso
  @@Base64EncoderBuffer
  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = Base64EncoderBuffer(*TamponSource, LongueurSource, *TamponDestination, LongueurDestination [, Options])    

@Description
  Encode le contenu d'un tampon avec l'algorithme Base64. 
  
@Parameter "*TamponSource"
  Le tampon contenant les données à coder.

@Parameter "LongueurSource"
  La taille de la mémoire tampon d'entrée.

@Parameter "*TamponDestination"
  Le tampon de sortie où les données codées 
  seront copiées.

@Parameter "LongueurDestination"
  La taille de la mémoire tampon de sortie.
@Indent
  La mémoire tampon de sortie peut être 
  jusqu'à 25% plus petite que le tampon 
  d'entrée, avec une taille minimale de 
  64 octets.@LineBreak
  Il est recommandé de faire un tampon 
  légèrement plus grand, par exemple 20%, 
  pour éviter les débordements.
@EndIndent

@OptionalParameter "Options"
  Peut être une combinaison de:
@FixedFont   
  @#PB_Cipher_NoPadding: Il ne sera pas plus insérer de '=' à la fin de la mémoire tampon.
  @#PB_Cipher_URL      : Utilisation d'un codage légèrement différent, principalement utilisé 
                         dans les URLs. Les caractères '+' et '/' seront respectivement codés 
                         en '-' et '_'.
@EndFixedFont
  
@ReturnValue
   Renvoie la longueur des données 
   codées en octets.

@Remarks
  Il est largement utilisé dans les 
  programmes de messagerie mais peut
  également être utile dans toute 
  application nécessitant un encodage 
  basé sur le code ASCII seul (7 bits, 
  caractères 32 à 127) pour les fichiers 
  binaires.
  
@Example
@Code
  Exemple$ = "Ceci est une chaîne !" 
  Decoded$ = Space(1024) 
  Encoded$ = Space(1024) 
    
  Debug Base64EncoderBuffer(@Exemple$, StringByteLength(Exemple$), @Encoded$, StringByteLength(Encoded$))
  Debug Encoded$ 
    
  Debug Base64DecoderBuffer(@Encoded$, StringByteLength(Encoded$), @Decoded$, StringByteLength(Decoded$))
  Debug Decoded$
@EndCode 

@Example Encodage & Décodage d'une DataSection
@Code
  DataSection
    TestDebut:
    Data.a $00, $01, $02, $03, $04, $05, $06, $07
    Data.a $08, $09, $0A, $0B, $0C, $0D, $0E, $0F
    TestFin:
  EndDataSection
  
  Taille = (?TestFin - ?TestDebut) * 1.35
  If Taille < 64
  Taille = 64
  EndIf
  
  *EncodeBuffer = AllocateMemory(Taille)
  Taille = Base64EncoderBuffer(?TestDebut, ?TestFin - ?TestDebut, *EncodeBuffer, MemorySize(*EncodeBuffer))
  ChaineEncodee$ = PeekS(*EncodeBuffer, Taille, #PB_Ascii)
  Debug ChaineEncodee$
  
  *DecodeBuffer = AllocateMemory(Taille)
  Taille = PokeS(*EncodeBuffer, ChaineEncodee$, StringByteLength(ChaineEncodee$, #PB_Ascii), #PB_Ascii|#PB_String_NoZero)
  Taille = Base64DecoderBuffer(*EncodeBuffer, Taille, *DecodeBuffer, MemorySize(*DecodeBuffer))
  ShowMemoryViewer(*DecodeBuffer, Taille)
@EndCode

@SeeAlso
  @@Base64DecoderBuffer
 
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = Base64Decoder(Source$, *TamponDestination, LongueurDestination)  

@Description
  Décode une chaîne de caractères encodée en @Link "Base64Encoder" "Base64". 

@Parameter "Source$"
  La chaîne de caractères à encoder.

@Parameter "*TamponDestination"
  Le tampon où les données brutes de sortie seront copiées.

@Parameter "LongueurDestination"
  La taille du tampon de sortie.
@LineBreak
@LineBreak
  Le tampon de sortie peut être jusqu'à 33% plus petit que le tampon d'entrée, 
  avec une taille minimale de 64 octets.@LineBreak
  Il est toutefois recommandé d'obtenir un tampon légèrement plus grand que 33%, comme 30% 
  plus petit pour éviter les débordements.

@ReturnValue
  Renvoie la longueur des données décodées en octets.

@Example
@Code
  String$ = "Voici un texte !"
  
  ; Encodage d'une chaîne Ascii
  *Texte = ASCII(String$)
    
  Encoder$ = Base64Encoder(*Texte, StringByteLength(String$, #PB_Ascii))
  Debug "Texte encodé: " + Encoder$
  
  *TamponDecoder = AllocateMemory(1024)
  Base64Decoder(Encoder$, *TamponDecoder, 1024)
  Debug "Texte décodé: " + PeekS(*TamponDecoder, -1, #PB_Ascii) + "'"
  
  FreeMemory(*Texte)
  FreeMemory(*TamponDecoder)
@EndCode

@SeeAlso
  @@Base64Encoder
  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat$ = Base64Encoder(*TamponSource, LongueurSource [, Options])  

@Description
Encode le tampon spécifié à l'aide de l'algorithme Base64. 
Ceci est largement utilisé dans les programmes de courrier électronique mais peut être utile 
pour tous les autres programmes qui ont besoin d'un codage ASCII uniquement (7 bits, 
seulement de 32 à 127 caractères) pour les fichiers binaires bruts. 

@Parameter "*TamponSource"
  Le tampon contenant les données brutes.

@Parameter "LongueurSource"
  La taille du tampon d'entrée.

@OptionalParameter "Options"
  Peut être une combinaison des valeurs suivantes:
@FixedFont  
  @#PB_Cipher_NoPadding: Pas de '=' supplémentaire à la fin de la mémoire tampon pour la combler à 3 octets.
  @#PB_Cipher_URL      : Codage légèrement différent, principalement utilisé dans les URLs. Les caractères '+' et '/' habituels
                        seront encodés respectivement en '-' et '_'
@EndFixedFont

@ReturnValue
  Renvoie les données codées sous forme de chaîne.

@Example
@Code
  String$ = "Voici un texte !"
  
  ; Encodage d'une chaîne 
  *Texte = UTF8( String$)
    
  Encoder$ = Base64Encoder(*Texte, StringByteLength(String$, #PB_UTF8))
  Debug "Texte encodé: " + Encoder$
  
  *TamponDecoder = AllocateMemory(1024)
  Base64Decoder(Encoder$, *TamponDecoder, 1024)
  Debug "Texte décodé: " + PeekS(*TamponDecoder, -1, #PB_UTF8) + "'"
  
  FreeMemory(*Texte)
  FreeMemory(*TamponDecoder)
@EndCode

@SeeAlso
  @@Base64Decoder, @@Base64DecoderBuffer, @@Base64EncoderBuffer
  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = StartAESCipher(#Cipher, *Cle, Bits, *VecteurInitialisation, Mode)

@Description
  Initialise un flux de chiffrement AES.

@Parameter "#Cipher"
  L'identifiant du nouveau chiffrement.
@LineBreak
@LineBreak
  @ReferenceLink "purebasic_objects" "#PB_Any" peut être utilisé pour générer 
  automatiquement ce numéro.

@Parameter "*Cle"
   Un tampon contenant la clé de décodage.
@Fixedfont
   Sa taille dépend du paramètre 'Bits': 
     l6 octets pour le cryptage 128 bits. 
     24 octets pour le cryptage 196 bits.
     32 octets pour le cryptage 256 bits.
@EndFixedfont

@Parameter "Bits"
   La taille de la clé utilisée par le chiffrement. @LineBreak
   Les valeurs valides sont 128, 192 et 256.@LineBreak
   @@DeriveCipherKey peut être utilisé pour créer cette clé à partir d'un mot de passe.
   
@Parameter "*VecteurInitialisation"
   Est un bloc de données aléatoires, 
   utilisé pour initialiser le chiffrement 
   et pour empêcher toute 
   violation de décodage (uniquement 
   nécessaire si vous utilisez le mode 
   @ConstantColor"#PB_Cipher_CBC").
@Fixedfont
   Sa taille dépend du paramètre 'Bits': 
     l6 octets pour le cryptage 128 bits. 
     24 octets pour le cryptage 196 bits.
     32 octets pour le cryptage 256 bits.
@EndFixedfont

@Parameter "Mode"
  Peut être une combinaison de: 
@FixedFont  
  @#PB_Cipher_Decode: Le flux est utilisé pour décoder les données.
  @#PB_Cipher_Encode: Le flux est utilisé pour encoder les données.
avec
  @#PB_Cipher_CBC: Mode par défaut (Cipher Block Chaining). Besoin de '*VecteurInitialisation'.
                  Recommandé car plus sûr que le mode ECB.
  @#PB_Cipher_ECB: Mode alternatif(Electronic CodeBook). Pas besoin de '*VecteurInitialisation'
                   ni de chaînage(chaque bloc est codé indépendamment). Cryptage très faible comparé à CBC
                   et ne devrait pas être utilisé pour un cryptage sérieux.
@EndFixedFont

@ReturnValue
  Si @#PB_Any a été utilisé pour le paramètre #Cipher alors un numéro généré automatiquement
  est renvoyé.

@Remarks
  Les nouveaux tampons à encoder ou à décoder peuvent être ajoutés avec @@AddCipherBuffer.
  @LineBreak
  @LineBreak
  Une fois le codage terminé, @@FinishCipher doit être appelé.
  @LineBreak
  @LineBreak
  Pour plus d'information à propos de AES, voir @@AESEncoder.

@SeeAlso
  @@AddCipherBuffer, @@FinishCipher, @@AESEncoder, @@AESDecoder, @@DeriveCipherKey
  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = OpenCryptRandom()

@Description
  Initialise l'accès au générateur de 
  nombres pseudo-aléatoires. 

@NoParameters

@ReturnValue
  Renvoie une valeur non nulle si le 
  générateur est correctement initialisé,  
  zéro s'il n'y a pas de générateur 
  pseudo-aléatoire robuste disponible 
  dans le système.

@Remarks
  Les commandes @@CryptRandom et 
  @@CryptRandomData peuvent être 
  utilisées pour lire les données 
  disponibles.
@LineBreak
@LineBreak
  Ce générateur est très robuste, assez 
  pour être utilisé à des fins de 
  cryptographie, comme la génération
  de clés pour la commande @@AESEncoder. 
  La source des données du générateur est 
  "/dev/urandom" sous Linux et MacOS X, 
  et la "Microsoft Cryptography API" 
  sous Windows. Il est néanmoins
  bien plus lent que la fonction 
  @@Random classique.
@LineBreak
@LineBreak
  Consulter @@CryptRandomData pour un 
  exemple d'utilisation.

@SeeAlso
  @@CryptRandom, @@CryptRandomData, 
  @@CloseCryptRandom

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function CloseCryptRandom()

@Description
  Libère les ressources utilisées par le 
  générateur de nombres pseudo-aléatoires 
  précédemment initialisé avec 
  @@OpenCryptRandom.

@NoParameters

@NoReturnValue

@SeeAlso
  @@OpenCryptRandom, @@CryptRandom, 
  @@CryptRandomData

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = CryptRandom(Maximum)

@Description
  Renvoie un nombre aléatoire (entier) 
  qui se trouve entre 0 (inclus) et la 
  valeur maximale du générateur 
  pseudo-aléatoire cryptographique.
  
@Parameter "Maximum"  
  Valeur maximale renvoyée par la fonction.
  @LineBreak
  Ne peut pas dépasser la valeur maximale 
  d'un @ReferenceLink "variables" "long": 
  2147483647.

@ReturnValue
  Renvoie le nombre aléatoire généré.

@Remarks
  Le générateur doit d'abord être ouvert 
  avec la commande @@OpenCryptRandom.
@LineBreak
@LineBreak
  @Bold "Important: " Utiliser une valeur 
  'Maximum' qui est égale à une puissance 
  de deux peut causer des probabilités 
  plus élevés pour certaines valeurs, 
  favorisant les attaques statistiques. 
  C'est la conséquence de la division du 
  nombre généré pour qu'il soit dans la 
  plage spécifiée.
@LineBreak
@LineBreak
  Pour générer des quantités plus 
  importantes de nombres aléatoires, 
  utilisez la commande @@CryptRandomData.
  Pour une génération beaucoup plus 
  rapide, mais moins robuste, utilisez 
  la commande @@Random.

@SeeAlso
  @@OpenCryptRandom, @@CryptRandomData, 
  @@CloseCryptRandom, @@Random

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = CryptRandomData(*Tampon, Longueur)

@Description
  Remplit une mémoire tampon avec des 
  données aléatoires provenant du 
  générateur pseudo-aléatoire 
  cryptographique .

@Parameter "*Tampon"
   Le tampon à remplir.

@Parameter "Longueur"
  La taille de la mémoire tampon en 
  octets.

@ReturnValue
  Renvoie une valeur non nulle si les 
  données aléatoires ont été générés 
  avec succès, zéro sinon.
  
@Remarks
Le générateur doit d'abord être ouvert 
avec la commande @@OpenCryptRandom.
@LineBreak
@LineBreak
  Pour une génération de données beaucoup 
  plus rapide, mais moins robuste, 
  utiliser la commande @@RandomData.

@Example
@Code
  *Cle = AllocateMemory(16)
  
  If OpenCryptRandom() And *Cle
    CryptRandomData(*Cle, 16)
    
    Texte$ = "Clé crée :"
    For i = 0 To 15
      Texte$ + " " + RSet(Hex(PeekB(*Cle+i), #PB_Byte), 2, "0")
    Next i     
    
    CloseCryptRandom()
  Else
    Texte$ = "La création de clé n'est pas disponible"
  EndIf
  
  MessageRequester("Exemple", Texte$)
@EndCode

@SeeAlso
  @@OpenCryptRandom, @@CryptRandom, @@CloseCryptRandom
  @@RandomData

@SupportedOS

;--------------------------------------------------------------------------------------------------------
